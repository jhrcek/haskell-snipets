-- Analysis of TestNG's emailable-report.html
{-# LANGUAGE OverloadedStrings #-}
import Data.Text (Text, lines, unlines, head, isInfixOf)
import Data.Text.IO (readFile, writeFile)
import Prelude hiding (readFile, writeFile, lines, unlines, head)
import System.Exit (exitFailure)
import System.Environment (getArgs)
import System.IO (hPutStrLn, stderr)
import Text.HTML.TagSoup (parseTags, renderTags, Tag(..))
import Text.HTML.TagSoup.Match (tagOpenAttrNameLit)

main :: IO ()
main = parseArgs >>= mkNewReport

parseArgs :: IO FilePath
parseArgs = do
    args <- getArgs
    case args of
        (f:_) -> return f
        _     -> hPutStrLn stderr "usage: clRep <path/to/emailable-report.html>" >> exitFailure 
      
mkNewReport :: FilePath -> IO ()
mkNewReport infile = readFile infile >>= writeFile "a.html" . removeClutter
  where 
    removeClutter :: Text -> Text
    removeClutter = renderTags . modifyStacktraces removeUndesiredLines . parseTags

type Stacktrace = Text 

-- Visit all stacktrace Tags (recognized by being preceeded by <div class="stacktrace">) and apply supplied function to their text
modifyStacktraces :: (Stacktrace -> Stacktrace) -> [Tag Text] -> [Tag Text]
modifyStacktraces modder = map snd . scanl f (False {- was previous tag stacktrace? -}, TagText "") 
  where f (False, _) curTag = (isStacktraceDiv curTag, curTag)
        f (True, _) stackTraceTag = (False, fmap modder stackTraceTag)

isStacktraceDiv :: Tag Text -> Bool
isStacktraceDiv = tagOpenAttrNameLit "div" "class" (=="stacktrace")

removeUndesiredLines :: Stacktrace -> Stacktrace
removeUndesiredLines = unlines . filter (not . isUndesiredLine) . lines

-- Determine line for removal (it starts with TAB and does not contain bxms or is autogenerated graphene proxy)
isUndesiredLine :: Text -> Bool
isUndesiredLine ln =   
    head ln == '\t'
    &&  not ( ".brms" `isInfixOf` ln || ".bpms" `isInfixOf` ln) 
    || "$$" `isInfixOf` ln {- exclude graphene generated classes -}
